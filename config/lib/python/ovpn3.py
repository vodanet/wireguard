# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ovpn3')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ovpn3')
    _ovpn3 = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ovpn3', [dirname(__file__)])
        except ImportError:
            import _ovpn3
            return _ovpn3
        try:
            _mod = imp.load_module('_ovpn3', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ovpn3 = swig_import_helper()
    del swig_import_helper
else:
    import _ovpn3
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class IPv4Addr(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPv4Addr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPv4Addr, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    SIZE = _ovpn3.IPv4Addr_SIZE

    def defined(self) -> "bool":
        return _ovpn3.IPv4Addr_defined(self)
    if _newclass:
        from_addr = staticmethod(_ovpn3.IPv4Addr_from_addr)
    else:
        from_addr = _ovpn3.IPv4Addr_from_addr
    if _newclass:
        from_in_addr = staticmethod(_ovpn3.IPv4Addr_from_in_addr)
    else:
        from_in_addr = _ovpn3.IPv4Addr_from_in_addr

    def to_in_addr(self) -> "in_addr":
        return _ovpn3.IPv4Addr_to_in_addr(self)
    if _newclass:
        from_sockaddr = staticmethod(_ovpn3.IPv4Addr_from_sockaddr)
    else:
        from_sockaddr = _ovpn3.IPv4Addr_from_sockaddr

    def to_sockaddr(self, port: 'unsigned short const'=0) -> "sockaddr_in":
        return _ovpn3.IPv4Addr_to_sockaddr(self, port)
    if _newclass:
        from_uint32 = staticmethod(_ovpn3.IPv4Addr_from_uint32)
    else:
        from_uint32 = _ovpn3.IPv4Addr_from_uint32

    def to_uint32(self) -> "std::uint32_t":
        return _ovpn3.IPv4Addr_to_uint32(self)
    if _newclass:
        from_uint32_net = staticmethod(_ovpn3.IPv4Addr_from_uint32_net)
    else:
        from_uint32_net = _ovpn3.IPv4Addr_from_uint32_net

    def to_byte_string(self, bytestr: 'unsigned char *') -> "void":
        return _ovpn3.IPv4Addr_to_byte_string(self, bytestr)

    def to_uint32_net(self) -> "std::uint32_t":
        return _ovpn3.IPv4Addr_to_uint32_net(self)
    if _newclass:
        from_ulong = staticmethod(_ovpn3.IPv4Addr_from_ulong)
    else:
        from_ulong = _ovpn3.IPv4Addr_from_ulong

    def to_ulong(self) -> "unsigned long":
        return _ovpn3.IPv4Addr_to_ulong(self)
    if _newclass:
        from_long = staticmethod(_ovpn3.IPv4Addr_from_long)
    else:
        from_long = _ovpn3.IPv4Addr_from_long

    def to_long(self) -> "long":
        return _ovpn3.IPv4Addr_to_long(self)
    if _newclass:
        from_bytes = staticmethod(_ovpn3.IPv4Addr_from_bytes)
    else:
        from_bytes = _ovpn3.IPv4Addr_from_bytes
    if _newclass:
        from_bytes_net = staticmethod(_ovpn3.IPv4Addr_from_bytes_net)
    else:
        from_bytes_net = _ovpn3.IPv4Addr_from_bytes_net
    if _newclass:
        from_zero = staticmethod(_ovpn3.IPv4Addr_from_zero)
    else:
        from_zero = _ovpn3.IPv4Addr_from_zero
    if _newclass:
        from_one = staticmethod(_ovpn3.IPv4Addr_from_one)
    else:
        from_one = _ovpn3.IPv4Addr_from_one
    if _newclass:
        from_zero_complement = staticmethod(_ovpn3.IPv4Addr_from_zero_complement)
    else:
        from_zero_complement = _ovpn3.IPv4Addr_from_zero_complement
    if _newclass:
        netmask_from_prefix_len = staticmethod(_ovpn3.IPv4Addr_netmask_from_prefix_len)
    else:
        netmask_from_prefix_len = _ovpn3.IPv4Addr_netmask_from_prefix_len

    def netmask_from_extent(self) -> "openvpn::IPv4::Addr":
        return _ovpn3.IPv4Addr_netmask_from_extent(self)
    if _newclass:
        from_string = staticmethod(_ovpn3.IPv4Addr_from_string)
    else:
        from_string = _ovpn3.IPv4Addr_from_string

    def to_string(self) -> "std::string":
        return _ovpn3.IPv4Addr_to_string(self)
    if _newclass:
        from_hex = staticmethod(_ovpn3.IPv4Addr_from_hex)
    else:
        from_hex = _ovpn3.IPv4Addr_from_hex

    def to_hex(self) -> "std::string":
        return _ovpn3.IPv4Addr_to_hex(self)

    def arpa(self) -> "std::string":
        return _ovpn3.IPv4Addr_arpa(self)

    def __and__(self, other: 'IPv4Addr') -> "openvpn::IPv4::Addr":
        return _ovpn3.IPv4Addr___and__(self, other)

    def __or__(self, other: 'IPv4Addr') -> "openvpn::IPv4::Addr":
        return _ovpn3.IPv4Addr___or__(self, other)

    def __add__(self, *args) -> "openvpn::IPv4::Addr":
        return _ovpn3.IPv4Addr___add__(self, *args)

    def __sub__(self, *args) -> "openvpn::IPv4::Addr":
        return _ovpn3.IPv4Addr___sub__(self, *args)

    def __mul__(self, other: 'IPv4Addr') -> "openvpn::IPv4::Addr":
        return _ovpn3.IPv4Addr___mul__(self, other)

    def __truediv__(self, *args):
        return _ovpn3.IPv4Addr___truediv__(self, *args)
    __div__ = __truediv__



    def __mod__(self, other: 'IPv4Addr') -> "openvpn::IPv4::Addr":
        return _ovpn3.IPv4Addr___mod__(self, other)

    def __lshift__(self, shift: 'unsigned int const') -> "openvpn::IPv4::Addr":
        return _ovpn3.IPv4Addr___lshift__(self, shift)

    def __rshift__(self, shift: 'unsigned int const') -> "openvpn::IPv4::Addr":
        return _ovpn3.IPv4Addr___rshift__(self, shift)

    def __invert__(self) -> "openvpn::IPv4::Addr":
        return _ovpn3.IPv4Addr___invert__(self)

    def network_addr(self, prefix_len: 'unsigned int const') -> "openvpn::IPv4::Addr":
        return _ovpn3.IPv4Addr_network_addr(self, prefix_len)

    def __eq__(self, other: 'IPv4Addr') -> "bool":
        return _ovpn3.IPv4Addr___eq__(self, other)

    def __ne__(self, other: 'IPv4Addr') -> "bool":
        return _ovpn3.IPv4Addr___ne__(self, other)

    def __lt__(self, other: 'IPv4Addr') -> "bool":
        return _ovpn3.IPv4Addr___lt__(self, other)

    def __gt__(self, other: 'IPv4Addr') -> "bool":
        return _ovpn3.IPv4Addr___gt__(self, other)

    def __le__(self, other: 'IPv4Addr') -> "bool":
        return _ovpn3.IPv4Addr___le__(self, other)

    def __ge__(self, other: 'IPv4Addr') -> "bool":
        return _ovpn3.IPv4Addr___ge__(self, other)

    def unspecified(self) -> "bool":
        return _ovpn3.IPv4Addr_unspecified(self)

    def specified(self) -> "bool":
        return _ovpn3.IPv4Addr_specified(self)

    def all_zeros(self) -> "bool":
        return _ovpn3.IPv4Addr_all_zeros(self)

    def all_ones(self) -> "bool":
        return _ovpn3.IPv4Addr_all_ones(self)

    def is_loopback(self) -> "bool":
        return _ovpn3.IPv4Addr_is_loopback(self)

    def prefix_len(self) -> "unsigned int":
        return _ovpn3.IPv4Addr_prefix_len(self)

    def prefix_len_nothrow(self) -> "int":
        return _ovpn3.IPv4Addr_prefix_len_nothrow(self)

    def host_len(self) -> "unsigned int":
        return _ovpn3.IPv4Addr_host_len(self)

    def extent_from_netmask(self) -> "openvpn::IPv4::Addr":
        return _ovpn3.IPv4Addr_extent_from_netmask(self)

    def extent_from_netmask_uint32(self) -> "std::uint32_t":
        return _ovpn3.IPv4Addr_extent_from_netmask_uint32(self)
    if _newclass:
        prefix_len_32 = staticmethod(_ovpn3.IPv4Addr_prefix_len_32)
    else:
        prefix_len_32 = _ovpn3.IPv4Addr_prefix_len_32
    if _newclass:
        size = staticmethod(_ovpn3.IPv4Addr_size)
    else:
        size = _ovpn3.IPv4Addr_size

    def hashval(self) -> "std::size_t":
        return _ovpn3.IPv4Addr_hashval(self)

    def __str__(self) -> "std::string":
        return _ovpn3.IPv4Addr___str__(self)

    def __repr__(self) -> "std::string":
        return _ovpn3.IPv4Addr___repr__(self)

    def __hash__(self):
        return self.hashval()


    marshall_type = str

    __swig_destroy__ = _ovpn3.delete_IPv4Addr
IPv4Addr_swigregister = _ovpn3.IPv4Addr_swigregister
IPv4Addr_swigregister(IPv4Addr)

def IPv4Addr_from_addr(addr: 'IPv4Addr') -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_from_addr(addr)
IPv4Addr_from_addr = _ovpn3.IPv4Addr_from_addr

def IPv4Addr_from_in_addr(in4: 'in_addr const *') -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_from_in_addr(in4)
IPv4Addr_from_in_addr = _ovpn3.IPv4Addr_from_in_addr

def IPv4Addr_from_sockaddr(sa: 'sockaddr_in const *') -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_from_sockaddr(sa)
IPv4Addr_from_sockaddr = _ovpn3.IPv4Addr_from_sockaddr

def IPv4Addr_from_uint32(addr: 'openvpn::IPv4::Addr::base_type const') -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_from_uint32(addr)
IPv4Addr_from_uint32 = _ovpn3.IPv4Addr_from_uint32

def IPv4Addr_from_uint32_net(addr: 'openvpn::IPv4::Addr::base_type const') -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_from_uint32_net(addr)
IPv4Addr_from_uint32_net = _ovpn3.IPv4Addr_from_uint32_net

def IPv4Addr_from_ulong(ul: 'unsigned long') -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_from_ulong(ul)
IPv4Addr_from_ulong = _ovpn3.IPv4Addr_from_ulong

def IPv4Addr_from_long(ul: 'long') -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_from_long(ul)
IPv4Addr_from_long = _ovpn3.IPv4Addr_from_long

def IPv4Addr_from_bytes(bytes: 'unsigned char const *') -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_from_bytes(bytes)
IPv4Addr_from_bytes = _ovpn3.IPv4Addr_from_bytes

def IPv4Addr_from_bytes_net(bytes: 'unsigned char const *') -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_from_bytes_net(bytes)
IPv4Addr_from_bytes_net = _ovpn3.IPv4Addr_from_bytes_net

def IPv4Addr_from_zero() -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_from_zero()
IPv4Addr_from_zero = _ovpn3.IPv4Addr_from_zero

def IPv4Addr_from_one() -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_from_one()
IPv4Addr_from_one = _ovpn3.IPv4Addr_from_one

def IPv4Addr_from_zero_complement() -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_from_zero_complement()
IPv4Addr_from_zero_complement = _ovpn3.IPv4Addr_from_zero_complement

def IPv4Addr_netmask_from_prefix_len(prefix_len: 'unsigned int const') -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_netmask_from_prefix_len(prefix_len)
IPv4Addr_netmask_from_prefix_len = _ovpn3.IPv4Addr_netmask_from_prefix_len

def IPv4Addr_from_string(ipstr: 'std::string const &', title: 'char const *'=None) -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_from_string(ipstr, title)
IPv4Addr_from_string = _ovpn3.IPv4Addr_from_string

def IPv4Addr_from_hex(s: 'std::string const &') -> "openvpn::IPv4::Addr":
    return _ovpn3.IPv4Addr_from_hex(s)
IPv4Addr_from_hex = _ovpn3.IPv4Addr_from_hex

def IPv4Addr_prefix_len_32(addr: 'std::uint32_t const') -> "int":
    return _ovpn3.IPv4Addr_prefix_len_32(addr)
IPv4Addr_prefix_len_32 = _ovpn3.IPv4Addr_prefix_len_32

def IPv4Addr_size() -> "unsigned int":
    return _ovpn3.IPv4Addr_size()
IPv4Addr_size = _ovpn3.IPv4Addr_size

class IPv6Addr(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPv6Addr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPv6Addr, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    SIZE = _ovpn3.IPv6Addr_SIZE

    def defined(self) -> "bool":
        return _ovpn3.IPv6Addr_defined(self)
    if _newclass:
        from_addr = staticmethod(_ovpn3.IPv6Addr_from_addr)
    else:
        from_addr = _ovpn3.IPv6Addr_from_addr
    if _newclass:
        from_in6_addr = staticmethod(_ovpn3.IPv6Addr_from_in6_addr)
    else:
        from_in6_addr = _ovpn3.IPv6Addr_from_in6_addr

    def to_in6_addr(self) -> "in6_addr":
        return _ovpn3.IPv6Addr_to_in6_addr(self)
    if _newclass:
        from_sockaddr = staticmethod(_ovpn3.IPv6Addr_from_sockaddr)
    else:
        from_sockaddr = _ovpn3.IPv6Addr_from_sockaddr

    def to_sockaddr(self, port: 'unsigned short const'=0) -> "sockaddr_in6":
        return _ovpn3.IPv6Addr_to_sockaddr(self, port)
    if _newclass:
        from_string = staticmethod(_ovpn3.IPv6Addr_from_string)
    else:
        from_string = _ovpn3.IPv6Addr_from_string

    def to_string(self) -> "std::string":
        return _ovpn3.IPv6Addr_to_string(self)
    if _newclass:
        from_hex = staticmethod(_ovpn3.IPv6Addr_from_hex)
    else:
        from_hex = _ovpn3.IPv6Addr_from_hex

    def to_hex(self) -> "std::string":
        return _ovpn3.IPv6Addr_to_hex(self)
    if _newclass:
        from_ulong = staticmethod(_ovpn3.IPv6Addr_from_ulong)
    else:
        from_ulong = _ovpn3.IPv6Addr_from_ulong

    def to_ulong(self) -> "unsigned long":
        return _ovpn3.IPv6Addr_to_ulong(self)
    if _newclass:
        from_long = staticmethod(_ovpn3.IPv6Addr_from_long)
    else:
        from_long = _ovpn3.IPv6Addr_from_long

    def to_long(self) -> "long":
        return _ovpn3.IPv6Addr_to_long(self)

    def arpa(self) -> "std::string":
        return _ovpn3.IPv6Addr_arpa(self)
    if _newclass:
        from_byte_string = staticmethod(_ovpn3.IPv6Addr_from_byte_string)
    else:
        from_byte_string = _ovpn3.IPv6Addr_from_byte_string

    def to_byte_string(self, bytestr: 'unsigned char *') -> "void":
        return _ovpn3.IPv6Addr_to_byte_string(self, bytestr)
    if _newclass:
        v4_to_byte_string = staticmethod(_ovpn3.IPv6Addr_v4_to_byte_string)
    else:
        v4_to_byte_string = _ovpn3.IPv6Addr_v4_to_byte_string
    if _newclass:
        byte_string_is_v4 = staticmethod(_ovpn3.IPv6Addr_byte_string_is_v4)
    else:
        byte_string_is_v4 = _ovpn3.IPv6Addr_byte_string_is_v4
    if _newclass:
        v4_from_byte_string = staticmethod(_ovpn3.IPv6Addr_v4_from_byte_string)
    else:
        v4_from_byte_string = _ovpn3.IPv6Addr_v4_from_byte_string
    if _newclass:
        from_zero = staticmethod(_ovpn3.IPv6Addr_from_zero)
    else:
        from_zero = _ovpn3.IPv6Addr_from_zero
    if _newclass:
        from_one = staticmethod(_ovpn3.IPv6Addr_from_one)
    else:
        from_one = _ovpn3.IPv6Addr_from_one
    if _newclass:
        from_zero_complement = staticmethod(_ovpn3.IPv6Addr_from_zero_complement)
    else:
        from_zero_complement = _ovpn3.IPv6Addr_from_zero_complement
    if _newclass:
        netmask_from_prefix_len = staticmethod(_ovpn3.IPv6Addr_netmask_from_prefix_len)
    else:
        netmask_from_prefix_len = _ovpn3.IPv6Addr_netmask_from_prefix_len

    def netmask_from_extent(self) -> "openvpn::IPv6::Addr":
        return _ovpn3.IPv6Addr_netmask_from_extent(self)

    def __and__(self, other: 'IPv6Addr') -> "openvpn::IPv6::Addr":
        return _ovpn3.IPv6Addr___and__(self, other)

    def __or__(self, other: 'IPv6Addr') -> "openvpn::IPv6::Addr":
        return _ovpn3.IPv6Addr___or__(self, other)

    def __add__(self, *args) -> "openvpn::IPv6::Addr":
        return _ovpn3.IPv6Addr___add__(self, *args)

    def __sub__(self, *args) -> "openvpn::IPv6::Addr":
        return _ovpn3.IPv6Addr___sub__(self, *args)

    def __mul__(self, d: 'IPv6Addr') -> "openvpn::IPv6::Addr":
        return _ovpn3.IPv6Addr___mul__(self, d)

    def __truediv__(self, *args):
        return _ovpn3.IPv6Addr___truediv__(self, *args)
    __div__ = __truediv__



    def __mod__(self, d: 'IPv6Addr') -> "openvpn::IPv6::Addr":
        return _ovpn3.IPv6Addr___mod__(self, d)

    def __lshift__(self, shift: 'unsigned int const') -> "openvpn::IPv6::Addr":
        return _ovpn3.IPv6Addr___lshift__(self, shift)

    def __rshift__(self, shift: 'unsigned int const') -> "openvpn::IPv6::Addr":
        return _ovpn3.IPv6Addr___rshift__(self, shift)

    def __invert__(self) -> "openvpn::IPv6::Addr":
        return _ovpn3.IPv6Addr___invert__(self)

    def network_addr(self, prefix_len: 'unsigned int const') -> "openvpn::IPv6::Addr":
        return _ovpn3.IPv6Addr_network_addr(self, prefix_len)

    def __eq__(self, other: 'IPv6Addr') -> "bool":
        return _ovpn3.IPv6Addr___eq__(self, other)

    def __ne__(self, other: 'IPv6Addr') -> "bool":
        return _ovpn3.IPv6Addr___ne__(self, other)

    def __lt__(self, other: 'IPv6Addr') -> "bool":
        return _ovpn3.IPv6Addr___lt__(self, other)

    def __gt__(self, other: 'IPv6Addr') -> "bool":
        return _ovpn3.IPv6Addr___gt__(self, other)

    def __le__(self, other: 'IPv6Addr') -> "bool":
        return _ovpn3.IPv6Addr___le__(self, other)

    def __ge__(self, other: 'IPv6Addr') -> "bool":
        return _ovpn3.IPv6Addr___ge__(self, other)

    def unspecified(self) -> "bool":
        return _ovpn3.IPv6Addr_unspecified(self)

    def specified(self) -> "bool":
        return _ovpn3.IPv6Addr_specified(self)

    def all_zeros(self) -> "bool":
        return _ovpn3.IPv6Addr_all_zeros(self)

    def all_ones(self) -> "bool":
        return _ovpn3.IPv6Addr_all_ones(self)

    def is_loopback(self) -> "bool":
        return _ovpn3.IPv6Addr_is_loopback(self)

    def bit(self, pos: 'unsigned int') -> "bool":
        return _ovpn3.IPv6Addr_bit(self, pos)

    def prefix_len(self) -> "unsigned int":
        return _ovpn3.IPv6Addr_prefix_len(self)

    def host_len(self) -> "unsigned int":
        return _ovpn3.IPv6Addr_host_len(self)

    def extent_from_netmask(self) -> "openvpn::IPv6::Addr":
        return _ovpn3.IPv6Addr_extent_from_netmask(self)
    if _newclass:
        size = staticmethod(_ovpn3.IPv6Addr_size)
    else:
        size = _ovpn3.IPv6Addr_size

    def hashval(self) -> "std::size_t":
        return _ovpn3.IPv6Addr_hashval(self)

    def __str__(self) -> "std::string":
        return _ovpn3.IPv6Addr___str__(self)

    def __repr__(self) -> "std::string":
        return _ovpn3.IPv6Addr___repr__(self)

    def __hash__(self):
        return self.hashval()


    marshall_type = str

    __swig_destroy__ = _ovpn3.delete_IPv6Addr
IPv6Addr_swigregister = _ovpn3.IPv6Addr_swigregister
IPv6Addr_swigregister(IPv6Addr)

def IPv6Addr_from_addr(addr: 'IPv6Addr') -> "openvpn::IPv6::Addr":
    return _ovpn3.IPv6Addr_from_addr(addr)
IPv6Addr_from_addr = _ovpn3.IPv6Addr_from_addr

def IPv6Addr_from_in6_addr(in6: 'in6_addr const *') -> "openvpn::IPv6::Addr":
    return _ovpn3.IPv6Addr_from_in6_addr(in6)
IPv6Addr_from_in6_addr = _ovpn3.IPv6Addr_from_in6_addr

def IPv6Addr_from_sockaddr(sa: 'sockaddr_in6 const *') -> "openvpn::IPv6::Addr":
    return _ovpn3.IPv6Addr_from_sockaddr(sa)
IPv6Addr_from_sockaddr = _ovpn3.IPv6Addr_from_sockaddr

def IPv6Addr_from_string(ipstr: 'std::string const &', title: 'char const *'=None) -> "openvpn::IPv6::Addr":
    return _ovpn3.IPv6Addr_from_string(ipstr, title)
IPv6Addr_from_string = _ovpn3.IPv6Addr_from_string

def IPv6Addr_from_hex(s: 'std::string const &') -> "openvpn::IPv6::Addr":
    return _ovpn3.IPv6Addr_from_hex(s)
IPv6Addr_from_hex = _ovpn3.IPv6Addr_from_hex

def IPv6Addr_from_ulong(ul: 'unsigned long') -> "openvpn::IPv6::Addr":
    return _ovpn3.IPv6Addr_from_ulong(ul)
IPv6Addr_from_ulong = _ovpn3.IPv6Addr_from_ulong

def IPv6Addr_from_long(ul: 'long') -> "openvpn::IPv6::Addr":
    return _ovpn3.IPv6Addr_from_long(ul)
IPv6Addr_from_long = _ovpn3.IPv6Addr_from_long

def IPv6Addr_from_byte_string(bytestr: 'unsigned char const *') -> "openvpn::IPv6::Addr":
    return _ovpn3.IPv6Addr_from_byte_string(bytestr)
IPv6Addr_from_byte_string = _ovpn3.IPv6Addr_from_byte_string

def IPv6Addr_v4_to_byte_string(bytestr: 'unsigned char *', v4addr: 'std::uint32_t const') -> "void":
    return _ovpn3.IPv6Addr_v4_to_byte_string(bytestr, v4addr)
IPv6Addr_v4_to_byte_string = _ovpn3.IPv6Addr_v4_to_byte_string

def IPv6Addr_byte_string_is_v4(bytestr: 'unsigned char const *') -> "bool":
    return _ovpn3.IPv6Addr_byte_string_is_v4(bytestr)
IPv6Addr_byte_string_is_v4 = _ovpn3.IPv6Addr_byte_string_is_v4

def IPv6Addr_v4_from_byte_string(bytestr: 'unsigned char const *') -> "std::uint32_t":
    return _ovpn3.IPv6Addr_v4_from_byte_string(bytestr)
IPv6Addr_v4_from_byte_string = _ovpn3.IPv6Addr_v4_from_byte_string

def IPv6Addr_from_zero() -> "openvpn::IPv6::Addr":
    return _ovpn3.IPv6Addr_from_zero()
IPv6Addr_from_zero = _ovpn3.IPv6Addr_from_zero

def IPv6Addr_from_one() -> "openvpn::IPv6::Addr":
    return _ovpn3.IPv6Addr_from_one()
IPv6Addr_from_one = _ovpn3.IPv6Addr_from_one

def IPv6Addr_from_zero_complement() -> "openvpn::IPv6::Addr":
    return _ovpn3.IPv6Addr_from_zero_complement()
IPv6Addr_from_zero_complement = _ovpn3.IPv6Addr_from_zero_complement

def IPv6Addr_netmask_from_prefix_len(prefix_len: 'unsigned int const') -> "openvpn::IPv6::Addr":
    return _ovpn3.IPv6Addr_netmask_from_prefix_len(prefix_len)
IPv6Addr_netmask_from_prefix_len = _ovpn3.IPv6Addr_netmask_from_prefix_len

def IPv6Addr_size() -> "unsigned int":
    return _ovpn3.IPv6Addr_size()
IPv6Addr_size = _ovpn3.IPv6Addr_size

class IPAddr(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPAddr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPAddr, name)
    UNSPEC = _ovpn3.IPAddr_UNSPEC
    V4 = _ovpn3.IPAddr_V4
    V6 = _ovpn3.IPAddr_V6
    V4_MASK = _ovpn3.IPAddr_V4_MASK
    V6_MASK = _ovpn3.IPAddr_V6_MASK
    V4_SIZE = _ovpn3.IPAddr_V4_SIZE
    V6_SIZE = _ovpn3.IPAddr_V6_SIZE

    def __init__(self, *args):
        this = _ovpn3.new_IPAddr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def validate_version(self, title: 'char const *', required_version: 'openvpn::IP::Addr::Version') -> "void":
        return _ovpn3.IPAddr_validate_version(self, title, required_version)
    if _newclass:
        validate = staticmethod(_ovpn3.IPAddr_validate)
    else:
        validate = _ovpn3.IPAddr_validate
    if _newclass:
        is_valid = staticmethod(_ovpn3.IPAddr_is_valid)
    else:
        is_valid = _ovpn3.IPAddr_is_valid
    if _newclass:
        from_string = staticmethod(_ovpn3.IPAddr_from_string)
    else:
        from_string = _ovpn3.IPAddr_from_string
    if _newclass:
        from_hex = staticmethod(_ovpn3.IPAddr_from_hex)
    else:
        from_hex = _ovpn3.IPAddr_from_hex
    if _newclass:
        from_ipv4 = staticmethod(_ovpn3.IPAddr_from_ipv4)
    else:
        from_ipv4 = _ovpn3.IPAddr_from_ipv4
    if _newclass:
        from_ipv6 = staticmethod(_ovpn3.IPAddr_from_ipv6)
    else:
        from_ipv6 = _ovpn3.IPAddr_from_ipv6

    def to_ipv4(self) -> "openvpn::IPv4::Addr const &":
        return _ovpn3.IPAddr_to_ipv4(self)

    def to_ipv6(self) -> "openvpn::IPv6::Addr const &":
        return _ovpn3.IPAddr_to_ipv6(self)

    def to_ipv4_nocheck(self) -> "openvpn::IPv4::Addr const &":
        return _ovpn3.IPAddr_to_ipv4_nocheck(self)

    def to_ipv6_nocheck(self) -> "openvpn::IPv6::Addr const &":
        return _ovpn3.IPAddr_to_ipv6_nocheck(self)
    if _newclass:
        from_sockaddr = staticmethod(_ovpn3.IPAddr_from_sockaddr)
    else:
        from_sockaddr = _ovpn3.IPAddr_from_sockaddr
    if _newclass:
        sockaddr_defined = staticmethod(_ovpn3.IPAddr_sockaddr_defined)
    else:
        sockaddr_defined = _ovpn3.IPAddr_sockaddr_defined
    if _newclass:
        from_ulong = staticmethod(_ovpn3.IPAddr_from_ulong)
    else:
        from_ulong = _ovpn3.IPAddr_from_ulong

    def to_ulong(self) -> "unsigned long":
        return _ovpn3.IPAddr_to_ulong(self)
    if _newclass:
        from_long = staticmethod(_ovpn3.IPAddr_from_long)
    else:
        from_long = _ovpn3.IPAddr_from_long

    def to_long(self) -> "long":
        return _ovpn3.IPAddr_to_long(self)
    if _newclass:
        from_byte_string = staticmethod(_ovpn3.IPAddr_from_byte_string)
    else:
        from_byte_string = _ovpn3.IPAddr_from_byte_string

    def to_byte_string(self, bytestr: 'unsigned char *') -> "void":
        return _ovpn3.IPAddr_to_byte_string(self, bytestr)

    def to_byte_string_variable(self, bytestr: 'unsigned char *') -> "void":
        return _ovpn3.IPAddr_to_byte_string_variable(self, bytestr)

    def to_uint32_net(self) -> "std::uint32_t":
        return _ovpn3.IPAddr_to_uint32_net(self)
    if _newclass:
        from_zero = staticmethod(_ovpn3.IPAddr_from_zero)
    else:
        from_zero = _ovpn3.IPAddr_from_zero
    if _newclass:
        from_one = staticmethod(_ovpn3.IPAddr_from_one)
    else:
        from_one = _ovpn3.IPAddr_from_one
    if _newclass:
        from_zero_complement = staticmethod(_ovpn3.IPAddr_from_zero_complement)
    else:
        from_zero_complement = _ovpn3.IPAddr_from_zero_complement
    if _newclass:
        validate_prefix_len = staticmethod(_ovpn3.IPAddr_validate_prefix_len)
    else:
        validate_prefix_len = _ovpn3.IPAddr_validate_prefix_len
    if _newclass:
        netmask_from_prefix_len = staticmethod(_ovpn3.IPAddr_netmask_from_prefix_len)
    else:
        netmask_from_prefix_len = _ovpn3.IPAddr_netmask_from_prefix_len

    def netmask_from_extent(self) -> "openvpn::IP::Addr":
        return _ovpn3.IPAddr_netmask_from_extent(self)

    def to_string(self) -> "std::string":
        return _ovpn3.IPAddr_to_string(self)

    def to_string_bracket_ipv6(self) -> "std::string":
        return _ovpn3.IPAddr_to_string_bracket_ipv6(self)

    def to_hex(self) -> "std::string":
        return _ovpn3.IPAddr_to_hex(self)

    def arpa(self) -> "std::string":
        return _ovpn3.IPAddr_arpa(self)

    def __add__(self, *args) -> "openvpn::IP::Addr":
        return _ovpn3.IPAddr___add__(self, *args)

    def __sub__(self, *args) -> "openvpn::IP::Addr":
        return _ovpn3.IPAddr___sub__(self, *args)

    def __mul__(self, other: 'IPAddr') -> "openvpn::IP::Addr":
        return _ovpn3.IPAddr___mul__(self, other)

    def __truediv__(self, *args):
        return _ovpn3.IPAddr___truediv__(self, *args)
    __div__ = __truediv__



    def __mod__(self, other: 'IPAddr') -> "openvpn::IP::Addr":
        return _ovpn3.IPAddr___mod__(self, other)

    def __and__(self, other: 'IPAddr') -> "openvpn::IP::Addr":
        return _ovpn3.IPAddr___and__(self, other)

    def __or__(self, other: 'IPAddr') -> "openvpn::IP::Addr":
        return _ovpn3.IPAddr___or__(self, other)

    def __lshift__(self, shift: 'unsigned int const') -> "openvpn::IP::Addr":
        return _ovpn3.IPAddr___lshift__(self, shift)

    def __rshift__(self, shift: 'unsigned int const') -> "openvpn::IP::Addr":
        return _ovpn3.IPAddr___rshift__(self, shift)

    def __invert__(self) -> "openvpn::IP::Addr":
        return _ovpn3.IPAddr___invert__(self)

    def network_addr(self, prefix_len: 'unsigned int const') -> "openvpn::IP::Addr":
        return _ovpn3.IPAddr_network_addr(self, prefix_len)

    def __eq__(self, other: 'IPAddr') -> "bool":
        return _ovpn3.IPAddr___eq__(self, other)

    def __ne__(self, other: 'IPAddr') -> "bool":
        return _ovpn3.IPAddr___ne__(self, other)

    def __lt__(self, other: 'IPAddr') -> "bool":
        return _ovpn3.IPAddr___lt__(self, other)

    def __gt__(self, other: 'IPAddr') -> "bool":
        return _ovpn3.IPAddr___gt__(self, other)

    def __le__(self, other: 'IPAddr') -> "bool":
        return _ovpn3.IPAddr___le__(self, other)

    def __ge__(self, other: 'IPAddr') -> "bool":
        return _ovpn3.IPAddr___ge__(self, other)

    def unspecified(self) -> "bool":
        return _ovpn3.IPAddr_unspecified(self)

    def specified(self) -> "bool":
        return _ovpn3.IPAddr_specified(self)

    def all_zeros(self) -> "bool":
        return _ovpn3.IPAddr_all_zeros(self)

    def all_ones(self) -> "bool":
        return _ovpn3.IPAddr_all_ones(self)

    def is_loopback(self) -> "bool":
        return _ovpn3.IPAddr_is_loopback(self)

    def defined(self) -> "bool":
        return _ovpn3.IPAddr_defined(self)

    def version_string(self) -> "char const *":
        return _ovpn3.IPAddr_version_string(self)
    if _newclass:
        version_string_static = staticmethod(_ovpn3.IPAddr_version_string_static)
    else:
        version_string_static = _ovpn3.IPAddr_version_string_static

    def version(self) -> "openvpn::IP::Addr::Version":
        return _ovpn3.IPAddr_version(self)

    def version_mask(self, *args) -> "openvpn::IP::Addr::VersionMask":
        return _ovpn3.IPAddr_version_mask(self, *args)

    def version_index(self) -> "int":
        return _ovpn3.IPAddr_version_index(self)

    def family(self) -> "int":
        return _ovpn3.IPAddr_family(self)

    def is_compatible(self, other: 'IPAddr') -> "bool":
        return _ovpn3.IPAddr_is_compatible(self, other)

    def is_ipv6(self) -> "bool":
        return _ovpn3.IPAddr_is_ipv6(self)

    def verify_version_consistency(self, other: 'IPAddr') -> "void":
        return _ovpn3.IPAddr_verify_version_consistency(self, other)

    def validate_netmask(self) -> "void":
        return _ovpn3.IPAddr_validate_netmask(self)

    def prefix_len(self) -> "unsigned int":
        return _ovpn3.IPAddr_prefix_len(self)

    def scope_id(self) -> "int":
        return _ovpn3.IPAddr_scope_id(self)

    def host_len(self) -> "unsigned int":
        return _ovpn3.IPAddr_host_len(self)

    def extent_from_netmask(self) -> "openvpn::IP::Addr":
        return _ovpn3.IPAddr_extent_from_netmask(self)

    def size(self) -> "unsigned int":
        return _ovpn3.IPAddr_size(self)

    def size_bytes(self) -> "unsigned int":
        return _ovpn3.IPAddr_size_bytes(self)
    if _newclass:
        version_size = staticmethod(_ovpn3.IPAddr_version_size)
    else:
        version_size = _ovpn3.IPAddr_version_size

    def hashval(self) -> "std::size_t":
        return _ovpn3.IPAddr_hashval(self)

    def __str__(self) -> "std::string":
        return _ovpn3.IPAddr___str__(self)

    def __repr__(self) -> "std::string":
        return _ovpn3.IPAddr___repr__(self)

    def __hash__(self):
        return self.hashval()


    marshall_type = str

    __swig_destroy__ = _ovpn3.delete_IPAddr
IPAddr_swigregister = _ovpn3.IPAddr_swigregister
IPAddr_swigregister(IPAddr)

def IPAddr_validate(*args) -> "std::string":
    return _ovpn3.IPAddr_validate(*args)
IPAddr_validate = _ovpn3.IPAddr_validate

def IPAddr_is_valid(ipstr: 'std::string const &') -> "bool":
    return _ovpn3.IPAddr_is_valid(ipstr)
IPAddr_is_valid = _ovpn3.IPAddr_is_valid

def IPAddr_from_string(*args) -> "openvpn::IP::Addr":
    return _ovpn3.IPAddr_from_string(*args)
IPAddr_from_string = _ovpn3.IPAddr_from_string

def IPAddr_from_hex(v: 'openvpn::IP::Addr::Version', s: 'std::string const &') -> "openvpn::IP::Addr":
    return _ovpn3.IPAddr_from_hex(v, s)
IPAddr_from_hex = _ovpn3.IPAddr_from_hex

def IPAddr_from_ipv4(addr: 'IPv4Addr') -> "openvpn::IP::Addr":
    return _ovpn3.IPAddr_from_ipv4(addr)
IPAddr_from_ipv4 = _ovpn3.IPAddr_from_ipv4

def IPAddr_from_ipv6(addr: 'IPv6Addr') -> "openvpn::IP::Addr":
    return _ovpn3.IPAddr_from_ipv6(addr)
IPAddr_from_ipv6 = _ovpn3.IPAddr_from_ipv6

def IPAddr_from_sockaddr(sa: 'sockaddr const *') -> "openvpn::IP::Addr":
    return _ovpn3.IPAddr_from_sockaddr(sa)
IPAddr_from_sockaddr = _ovpn3.IPAddr_from_sockaddr

def IPAddr_sockaddr_defined(sa: 'sockaddr const *') -> "bool":
    return _ovpn3.IPAddr_sockaddr_defined(sa)
IPAddr_sockaddr_defined = _ovpn3.IPAddr_sockaddr_defined

def IPAddr_from_ulong(v: 'openvpn::IP::Addr::Version', ul: 'unsigned long') -> "openvpn::IP::Addr":
    return _ovpn3.IPAddr_from_ulong(v, ul)
IPAddr_from_ulong = _ovpn3.IPAddr_from_ulong

def IPAddr_from_long(v: 'openvpn::IP::Addr::Version', ul: 'long') -> "openvpn::IP::Addr":
    return _ovpn3.IPAddr_from_long(v, ul)
IPAddr_from_long = _ovpn3.IPAddr_from_long

def IPAddr_from_byte_string(bytestr: 'unsigned char const *') -> "openvpn::IP::Addr":
    return _ovpn3.IPAddr_from_byte_string(bytestr)
IPAddr_from_byte_string = _ovpn3.IPAddr_from_byte_string

def IPAddr_from_zero(v: 'openvpn::IP::Addr::Version') -> "openvpn::IP::Addr":
    return _ovpn3.IPAddr_from_zero(v)
IPAddr_from_zero = _ovpn3.IPAddr_from_zero

def IPAddr_from_one(v: 'openvpn::IP::Addr::Version') -> "openvpn::IP::Addr":
    return _ovpn3.IPAddr_from_one(v)
IPAddr_from_one = _ovpn3.IPAddr_from_one

def IPAddr_from_zero_complement(v: 'openvpn::IP::Addr::Version') -> "openvpn::IP::Addr":
    return _ovpn3.IPAddr_from_zero_complement(v)
IPAddr_from_zero_complement = _ovpn3.IPAddr_from_zero_complement

def IPAddr_validate_prefix_len(v: 'openvpn::IP::Addr::Version', prefix_len: 'unsigned int const') -> "bool":
    return _ovpn3.IPAddr_validate_prefix_len(v, prefix_len)
IPAddr_validate_prefix_len = _ovpn3.IPAddr_validate_prefix_len

def IPAddr_netmask_from_prefix_len(v: 'openvpn::IP::Addr::Version', prefix_len: 'unsigned int const') -> "openvpn::IP::Addr":
    return _ovpn3.IPAddr_netmask_from_prefix_len(v, prefix_len)
IPAddr_netmask_from_prefix_len = _ovpn3.IPAddr_netmask_from_prefix_len

def IPAddr_version_string_static(ver: 'openvpn::IP::Addr::Version') -> "char const *":
    return _ovpn3.IPAddr_version_string_static(ver)
IPAddr_version_string_static = _ovpn3.IPAddr_version_string_static

def IPAddr_version_size(v: 'openvpn::IP::Addr::Version') -> "unsigned int":
    return _ovpn3.IPAddr_version_size(v)
IPAddr_version_size = _ovpn3.IPAddr_version_size

# This file is compatible with both classic and new-style classes.


